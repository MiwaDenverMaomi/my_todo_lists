つまずいた箇所をもとにまとめました。のちの参考に。

★ログイン認証
①Auth::attemptを使用して初めてAuth::id()などが使えるようになる。
②make:authをすると、ログインに必要なview,controllers,web.phpのルートが追加される。使わなくてもOK。
③Authファサードは、make:authしなくても使える、、、はず。

★web.php
①apiを使用する際に、/apiというパスはルート内に必須ではない。
②''でなく``でルートを記述すると、ルートが全く認識されなくなるので、``は使用しない。
③ルートの中にダイレクトにモデル名を入れることができる。コントローラーで受け取る際には、User $userというふうに
アーギュメントを渡す。例）ルート：'/edit/{user}'＝＞コントローラーの引数：User $user
④nameはネストできる。後が続く場合は、末尾にピリオドをつける。例：('user.')...('profile')
⑤値の送受信のしかた

1)laravel<->bladeの場合

ルート例）
※TodoはApp\Models\Todoからインポートしておく。
※ルートの別名はネストできるので、分かりやすく命名する。
Route::get('/todo-list',[Todo::class,getTodo])->name('todo.get');
Route::post('/todo-list',[Todo::class,postTodo])->name('todo.post');
Route::patch('/todo-list/{user}',[Todo::class,updateTitle])->name('todo.update-title');

コントローラー例）
①バリデーションは、コントローラー内で行うとごちゃごちゃするので、フォームリクエスト内ですませるのが理想。
ここでひっかかれば、自動的にフォームでエラーメッセージが表示される。※blade内でエラー表示欄に@error {{$message}} @enderrorを記述する。
②DBにアクセスし、データ取得・更新後にその戻り値によってエラーハンドリングの分岐をさせる。
eloquentのcreateを使って新規作成した場合、その戻り値は新規作成したレコードのモデルが帰ってくるので、返り値を$resultに代入した場合、!empty($result)で分岐させる。
update,deleteの場合は、戻り値は更新したレコード数が帰る（1か0）。私がテストしたところtrue（成功）／false（失敗）で帰る（->phpの場合1/0と同等か？）。もしかしたら、print(xxx,true)で
確認したらもっと詳しいデータがでるかもしれない。


ブレード例)
※post送信
<form method="post" action="{{route('todo.post')}}">
@csrf

※patch送信
<form method="post" action="{{route('todo.update-title',['todo'=>$item['id']])}}">
@csrf
@method('patch')<-必須。htmlではpostとgetしかサポートしていないため。method="post"も記述。

★patch送信(api不使用)の実例：
<blade側>
※ルート名は、エイリアスで記述。渡すパラメータは、第二引数として入れる。tsでのaction=が効いてなさそうだったので、第二引数に['bucket_list'=>$item['id']]を入れた。
<form id="todo_title_form" method="post" action="{{route('bucket-lists.update-title',['bucket_list'=>$item['id']])}}" onsubmit="onSubmit()">
								@csrf
								@method('patch')
							<p id={{"todo_display_".$item['id']}} @class(['textdecoration-linethrough'=>$item['is_done']]) onclick="onStartEditMode({{$item['id']}},'{{$item['bucket_list_item']}}','{{$item['is_done']}}')">{{$item['bucket_list_item']}}</p>
							</form>

<ts側>
※引数のtodo_idは、routeでは{bucket_list}としてモデルバインディングされて渡される。
同時にsubmitされたフォームのリクエストも渡される。フォームの内容はコントローラではRequest $requestに入っており、プロパティ名（htmlでのname属性）で取り出せる。
（$request->emailなどのように）

export const onSubmitTitle=(todo_id:number)=>{
	console.log('onSubmit');
	const $todo_title_form_element=document.querySelector<any>("#todo_title_form");
			$todo_title_form_element.method="post";
			$todo_title_form_element.action=`/todo-list/update-title/${todo_id}`;//Not working?
			$todo_title_form_element.submit();
};

※$todo_title_form_element.action=`/todo-list/update-title/${todo_id}にNot working?とあるが、これは
"`/todo-list/update-title/${todo_id}`"とすべきだったのかもしれない。

<controller/update-title>
※Bucket_list $bucket_listにはルート{bucket_list}でモデルバインディングされた値が入る。
public function updateTitle(Request $request,Bucket_list $bucket_list){
		\Log::info('update');

		$validator=Validator::make($request->all(),[
			"title"=>"required | max:255"
		],[
			"title.required"=>"Input todo.",
			"tite.max"=>"Input less than 255 letters."
		]);

		if($validator->fails()){
			\Log::debug($validator);
			return back()
			->withErrors($validator)
			->withInput();

		}else{
			 $bucket_list->bucket_list_item=$request->title;
			 $result=$bucket_list->save();

			 if($result===true){
				 return redirect()->route('bucket-lists.show',['user'=>$bucket_list->user_id]);
			 }else{
				 return back()->with([`update_title_error`=>'Failed to save data. Please try again later.']);
			 }
		}


★フォームリクエスト
①コントローラー内でバリデーションすると、記述量が多くなるので、バリデーションはフォームリクエスト内ですますと良い。
②フォームリクエスト内でバリデーションルールとメッセージを任意で設定する。
③同時にbladeでエラーメッセージ表示エリアを記述する。

★api
①axiosで通信したときと、fetchで通信したときは、レスポンスの中身は若干ことなる。

★bladeの変数の書き方
①要素のプロパティは""で必ずくくる。(例1)
②引数に変数を使う場合は、変数ごとに{{}}でくくる。onclick="onToggleike({{$list['user']['id']}},{{$list['is_liked_by_auth']}})"(例1)
③id名などを動的に変更したい場合は、””でくくる。例：id="like-id_{{$list['user']['id']}}"(例1)
④＠class([a=>b])を利用できる。bがtrueのとき、a(クラス名)が適用される。(例2)

例1:
<i class="{{$user_data['is_liked_by_auth']===true?'fa-solid fa-heart active icon-pink':'fa-solid fa-heart icon-grey'}}"></i>
例2：<p @class(['textdecoration-linethrough'=>$item['is_done']])>

★エラー表示のステップ(larabel->blade)
①バリデーションによる表示
方法１：フォームリクエストでバリデーション
方法２：コントローラー内でバリデーション
コントローラー側：
return back()
			->withErrors($validator)
			->withInput();

②sessionを使う。
一度のエラーメッセージは、session('flash_message','xxx')でフラッシュメッセージとして入れることができる。これは、
バリデーションにも使えるし、例外エラーを投げるときに使用しても良い。
例）
コントローラー側：back()->with(['flash_message','xxxx']);でflash_messageを入れることができる。
blade側：session('flash_message')で取り出す

★エラー表示のしかた
方法１：bladeで@error('XXX') {{$message}} @enderrorで表示
方法２: bladeで@if(session('flash_message')){{session('flash_message')}} @endif

★エラー表示のメソッド
方法１：first
エラーひとつだけ表示
{{$errors->has('name')?$errors->first('name'):''}}
方法2:all?
ひとつのname属性のエラーを全部表示する。（要ググる）

★画像のアップロード～全体の流れ
ステップ①画像選択ー＞プレビュー表示
ステップ②送信->javascriptでバリデーション。OKなら送信。Ngならエラーメッセージ表示。
ステップ③画像をバリデーション。
ステップ④選択した画像を保存するディレクトリの名前、画像ファイルの名前を生成する。
ステップ⑤選択した画像をstorageに入れる(storeAs)
---------------ここまでが指定画像を指定のパスにいれる作業。DBには画像パス名は保存されていない。
ステップ⑥画像パスをDBに保存。


blade側
①enctype=”multipart/form-data”をformタグに記述。
②<input type="file">で画像ファイル選択可能。
③accept=""で許可するファイル形式を指定。
<input type="file" name="photo" accept=".png, .jpeg, .jpg" 
id="input_photo" onchange="onHandleSelectPhoto('{{$user_data['name']}}')" style="opacity:0;">

controller側
①画像保存先のディレクトリ名生成：$dir='sample';
②画像のファイル名を取得
$file_name=$file_name = $request->file('image')->getClientOriginalName();
③保存先ディレクトリ＋ファイル名を指定して、画像を保存する//->保存先はstorage/public以下になる。
$request->file('<name属性名>')->storeAs('public/'.$dir,$file_name);
//->storage/app/public/sample/XXXXXXXX.jpg
④DBに画像保存先のパスを保存する。
※画像選択で取得する値がNULLの場合は、’public/img/no_image.jpg'をDBに保存する
例）Photo::create([
'file_name'=>$file_name,
'path'=>'storage/.$dir.'/'.$file_name
]);

★選択した画像をプレビュー
ステップ①送信された画像を取得
ステップ②オブジェクトになっているので、配列に変換
ステップ③それぞれバリデーションする
ステップ④
バリデーションＯＫの場合はプレビューに表示
ＮＧの場合はプレビュー表示せずにエラーメッセージ表示
<サンプル>
 <form action="">
      <div>
        <label for="input">画像ファイル</label>
        <input type="file" name="input" id="input" accept="image/*">
        <figure id="figure" style="display: none">
          <figcaption>画像ファイルのプレビュー</figcaption>
          <img src="" alt="" id="figureImage" style="max-width: 100%">
        </figure>
      </div>
    </form>
-----------------------------------------------------
input.addEventListener('change', (event) => { // <1>
    const [file] = event.target.files

    if (file) {
      figureImage.setAttribute('src', URL.createObjectURL(file))★setAttributeを使うのがポイント
      figure.style.display = 'block'★普段非表示で、画像選択されたときは表示する
    } else {
      figure.style.display = 'none'
    }
  })
★画像大きさについて
iphoneの場合：
写真のデータサイズ(ファイルサイズ)は、画素数と比例します。 iPhone 4S以降、iSightカメラ(背面カメラ)の画質は
約800万のまま据え置かれているため、動作対象モデルがiPhone 4S以降となったiOS 8では、どのiPhoneを利用しても
2メガバイト前後で撮影されます。

参考ピクセル数：
約1200万画素 (3968×2976)
約800万画素 (3264×2448)->私の携帯
※https://digital-faq.olympus.co.jp/faq/public/app/servlet/qadoc?QID=006995

phpのデフォルトでは限界が8Mなので、controllerでは以下のように設定した。（800万画素）
	"photo"=>'image|mimes:jpeg,png,jpg|max:8192|dimensions:max_width=2448',
※私の携帯の画像は、800万画素、dimensions:2448 X 3264, width:2448, height:3264
size:2.18 MB (2,295,953 bytes)だった。800万画素で約2MBと覚えておこう。

★asset('パス')public フォルダのパス上にある画像を表示する。※storage/app/publicではないことに注意
例）
<img src="{{asset('img/no_image.jpg')}}" class="img-circle d-block mx-auto" alt="{{$user_data['name'].'_photo'}}"  width="100" height="100">

★バリデーション ルールのnullable ->nullOKなものに設定する。出ないとnullをバリデーションしたときにエラーになる場合がある。

★プロフィール編集の流れは以下。
※プロフィールでは名前などを設定できるがすべてのカラムがnullableであるとする。
①DBでは画像含め、NullOKのカラムにはNullを入れておく。'No name'とかデフォルトで入れない。
②プロフィール編集では、初期表示のときにDBカラムがnullの場合はXXXを表示するという記述をしておく。
例）blade側：!empty($user['name']){{$user['name']}}:'No name'
こうすることで、会員登録したばかりのユーザーが初めてプロフィールを表示したときにNullの代わりに'No name'が表示される。
③プロフィール編集をし送信する場合は、blade側からvalueの値を送信し、controllerで$requestとして受け取る。（name属性がキーとなる）
④バリデーションする
⑤バリデーションＯＫの場合、Nullの場合は'No name'をインサートする。（blade上では$user['name']がemptyの場合は、'No comment'と表示するようにしているため、自動的に'No comment'が
valueとして入っている。なので、Nullがcontrollerで受け取られることはあり得ないのだが、こういう記述をしている。）
⑥写真アップロードの場合は、以下の条件で分岐させる。（ＤＢ初期状態はnull）
1)$request->photoがemptyかどうかをチェック
2)emptyでない場合は、$request->photoでＤＢに画像パス登録
3)emptyの場合は、DBのphotoがNullかどうかをチェックする。Profile::where('user_id','=',$requet->user_id)->photoがNullかどうかをチェックする。
4)Nullである場合は、写真をアップロードしない（photoカラムを更新しない）
5)Nullでない場合(既存の画像パスがある場合)は、$request->photoでDBに画像パスを登録する。
⑦blade側でも、nullの場合は、no_image.jpgを表示するよう設定する。
例）
<img id="photo_preview_image" src="{{ !empty($user_data['profile']['
photo'])?asset($user_data['profile']['photo']):asset('img/no_image.jpg')}}" class="rounded-circle d-block mx-auto position-pic" alt="{{$user_data['name'].'_photo'}}" width="100" height="100">

★ポリシーの設定
現状、ログイン中ならばURLを操作することにより、別ユーザーのプロフィールを編集できてしまう。
それを防ぐために、ポリシーを設定する。
①php artisan make:policy ProfilePolicy
②App/Policies/PrifilePolicyに以下の記述をする
※必ずユーザーモデルと別モデルのインスタンスを紐づけるようにする
public function checkUser(User $user,Profile $profile){
      if($user->id===$profile->user_id){
        return true;
      }
    }
③AuthServiceProvider.phpに登録
サービスプロバイダーに登録※ここで登録したものがデフォルトのポリシーの紐づけよりも優先される
  protected $policies = [
        'App\Models\Profile' => 'App\Policies\ProfilePolicy',
    ];
④コントローラーのconstructorに記述※middleware->authをweb.phpに記述していることが前提
 $this->middleware('can:checkUser,profile')->only([
            'editProfileMode','showProfile','editProfile'
        ]);

★エラーメッセージ
@if($errors->has('password'))
  $errors->first('password')
@endif
は以下と同じ
 @error('password')
    <div class="text-center text-danger mb-0">
              {{$message}}
		</div>
    @enderror

★withInput()/old
前回の値を引き継ぐ。
<input type="text" class="form-control" id="name" placeholder="No name" value="{{old('name',!empty($user_data['name'])?$user_data['name']:'No name')}}" name="name">