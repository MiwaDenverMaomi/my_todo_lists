つまずいた箇所をもとにまとめました。のちの参考に。

★ログイン認証
①Auth::attemptを使用して初めてAuth::id()などが使えるようになる。
②make:authをすると、ログインに必要なview,controllers,web.phpのルートが追加される。使わなくてもOK。
③Authファサードは、make:authしなくても使える、、、はず。

★web.php
①apiを使用する際に、/apiというパスはルート内に必須ではない。
②''でなく``でルートを記述すると、ルートが全く認識されなくなるので、``は使用しない。
③ルートの中にダイレクトにモデル名を入れることができる。コントローラーで受け取る際には、User $userというふうに
アーギュメントを渡す。例）ルート：'/edit/{user}'＝＞コントローラーの引数：User $user
④nameはネストできる。後が続く場合は、末尾にピリオドをつける。例：('user.')...('profile')
⑤値の送受信のしかた

1)laravel<->bladeの場合

ルート例）
※TodoはApp\Models\Todoからインポートしておく。
※ルートの別名はネストできるので、分かりやすく命名する。
Route::get('/todo-list',[Todo::class,getTodo])->name('todo.get');
Route::post('/todo-list',[Todo::class,postTodo])->name('todo.post');
Route::patch('/todo-list/{user}',[Todo::class,updateTitle])->name('todo.update-title');

コントローラー例）
①バリデーションは、コントローラー内で行うとごちゃごちゃするので、フォームリクエスト内ですませるのが理想。
ここでひっかかれば、自動的にフォームでエラーメッセージが表示される。※blade内でエラー表示欄に@error {{$message}} @enderrorを記述する。
②DBにアクセスし、データ取得・更新後にその戻り値によってエラーハンドリングの分岐をさせる。
eloquentのcreateを使って新規作成した場合、その戻り値は新規作成したレコードのモデルが帰ってくるので、返り値を$resultに代入した場合、!empty($result)で分岐させる。
update,deleteの場合は、戻り値は更新したレコード数が帰る（1か0）。私がテストしたところtrue（成功）／false（失敗）で帰る（->phpの場合1/0と同等か？）。もしかしたら、print(xxx,true)で
確認したらもっと詳しいデータがでるかもしれない。


ブレード例)
※post送信
<form method="post" action="{{route('todo.post')}}">
@csrf

※patch送信
<form method="post" action="{{route('todo.update-title',['todo'=>$item['id']])}}">
@csrf
@method('patch')<-必須。htmlではpostとgetしかサポートしていないため。method="post"も記述。

★patch送信(api不使用)の実例：
<blade側>
※ルート名は、エイリアスで記述。渡すパラメータは、第二引数として入れる。tsでのaction=が効いてなさそうだったので、第二引数に['bucket_list'=>$item['id']]を入れた。
<form id="todo_title_form" method="post" action="{{route('bucket-lists.update-title',['bucket_list'=>$item['id']])}}" onsubmit="onSubmit()">
								@csrf
								@method('patch')
							<p id={{"todo_display_".$item['id']}} @class(['textdecoration-linethrough'=>$item['is_done']]) onclick="onStartEditMode({{$item['id']}},'{{$item['bucket_list_item']}}','{{$item['is_done']}}')">{{$item['bucket_list_item']}}</p>
							</form>

<ts側>
※引数のtodo_idは、routeでは{bucket_list}としてモデルバインディングされて渡される。
同時にsubmitされたフォームのリクエストも渡される。フォームの内容はコントローラではRequest $requestに入っており、プロパティ名（htmlでのname属性）で取り出せる。
（$request->emailなどのように）

export const onSubmitTitle=(todo_id:number)=>{
	console.log('onSubmit');
	const $todo_title_form_element=document.querySelector<any>("#todo_title_form");
			$todo_title_form_element.method="post";
			$todo_title_form_element.action=`/todo-list/update-title/${todo_id}`;//Not working?
			$todo_title_form_element.submit();
};

※$todo_title_form_element.action=`/todo-list/update-title/${todo_id}にNot working?とあるが、これは
"`/todo-list/update-title/${todo_id}`"とすべきだったのかもしれない。

<controller/update-title>
※Bucket_list $bucket_listにはルート{bucket_list}でモデルバインディングされた値が入る。
public function updateTitle(Request $request,Bucket_list $bucket_list){
		\Log::info('update');

		$validator=Validator::make($request->all(),[
			"title"=>"required | max:255"
		],[
			"title.required"=>"Input todo.",
			"tite.max"=>"Input less than 255 letters."
		]);

		if($validator->fails()){
			\Log::debug($validator);
			return back()
			->withErrors($validator)
			->withInput();

		}else{
			 $bucket_list->bucket_list_item=$request->title;
			 $result=$bucket_list->save();

			 if($result===true){
				 return redirect()->route('bucket-lists.show',['user'=>$bucket_list->user_id]);
			 }else{
				 return back()->with([`update_title_error`=>'Failed to save data. Please try again later.']);
			 }
		}


★フォームリクエスト
①コントローラー内でバリデーションすると、記述量が多くなるので、バリデーションはフォームリクエスト内ですますと良い。
②フォームリクエスト内でバリデーションルールとメッセージを任意で設定する。
③同時にbladeでエラーメッセージ表示エリアを記述する。

★api
①axiosで通信したときと、fetchで通信したときは、レスポンスの中身は若干ことなる。

★bladeの変数の書き方
①要素のプロパティは""で必ずくくる。(例1)
②引数に変数を使う場合は、変数ごとに{{}}でくくる。onclick="onToggleike({{$list['user']['id']}},{{$list['is_liked_by_auth']}})"(例1)
③id名などを動的に変更したい場合は、””でくくる。例：id="like-id_{{$list['user']['id']}}"(例1)
④＠class([a=>b])を利用できる。bがtrueのとき、a(クラス名)が適用される。(例2)

例1:
@php
$heart_class=$list['is_liked_by_auth']===true?'fa-solid fa-heart icon active':'fa-solid fa-heart icon';
@endphp
<i id="like-id_{{$list['user']['id']}}" class="{{$heart_class}}" onclick="onToggleLike({{$list['user']['id']}},{{$list['is_liked_by_auth']}})"></i><strong id="count_likes_{{$list['user']['id']}}">{{count($list['user']['likes'])}}</strong>
						<div class="text-center text-warging" id="likes_result_{{$list['user']['id']}}">
						</div>
例2：<p @class(['textdecoration-linethrough'=>$item['is_done']])>

★エラー表示のステップ(larabel->blade)
①バリデーションによる表示
方法１：フォームリクエストでバリデーション
方法２：コントローラー内でバリデーション
コントローラー側：
return back()
			->withErrors($validator)
			->withInput();

②sessionを使う。
一度のエラーメッセージは、session('flash_message','xxx')でフラッシュメッセージとして入れることができる。これは、
バリデーションにも使えるし、例外エラーを投げるときに使用しても良い。
例）
コントローラー側：back()->with(['flash_message','xxxx']);でflash_messageを入れることができる。
blade側：session('flash_message')で取り出す

★エラー表示のしかた
方法１：bladeで@error('XXX') {{$message}} @enderrorで表示
方法２: bladeで@if(session('flash_message')){{session('flash_message')}} @endif

★エラー表示のメソッド
方法１：first
エラーひとつだけ表示
{{$errors->has('name')?$errors->first('name'):''}}
方法2:all?
ひとつのname属性のエラーを全部表示する。（要ググる）

★画像のアップロード～全体の流れ
ステップ①画像選択ー＞プレビュー表示
ステップ②送信->javascriptでバリデーション。OKなら送信。Ngならエラーメッセージ表示。
ステップ③画像をバリデーション。
ステップ④選択した画像を保存するディレクトリの名前、画像ファイルの名前を生成する。
ステップ⑤選択した画像をstorageに入れる(storeAs)
---------------ここまでが指定画像を指定のパスにいれる作業。DBには画像パス名は保存されていない。
ステップ⑥画像パスをDBに保存。


blade側
①enctype=”multipart/form-data”をformタグに記述。
②<input type="file">で画像ファイル選択可能。
③accept=""で許可するファイル形式を指定。
<input type="file" name="photo" accept=".png, .jpeg, .jpg" 
id="input_photo" onchange="onHandleSelectPhoto('{{$user_data['name']}}')" style="opacity:0;">

controller側
①画像保存先のディレクトリ名生成：$dir='sample';
②画像のファイル名を取得
$file_name=$file_name = $request->file('image')->getClientOriginalName();
③保存先ディレクトリ＋ファイル名を指定して、画像を保存する//->保存先はstorage/public以下になる。
$request->file('<name属性名>')->storeAs('public/'.$dir,$file_name);
//->storage/app/public/sample/XXXXXXXX.jpg
④DBに画像保存先のパスを保存する。
※画像選択で取得する値がNULLの場合は、’public/img/no_image.jpg'をDBに保存する
例）Photo::create([
'file_name'=>$file_name,
'path'=>'storage/.$dir.'/'.$file_name
]);

★選択した画像をプレビュー
ステップ①送信された画像を取得
ステップ②オブジェクトになっているので、配列に変換
ステップ③それぞれバリデーションする
ステップ④
バリデーションＯＫの場合はプレビューに表示
ＮＧの場合はプレビュー表示せずにエラーメッセージ表示
<サンプル>
 <form action="">
      <div>
        <label for="input">画像ファイル</label>
        <input type="file" name="input" id="input" accept="image/*">
        <figure id="figure" style="display: none">
          <figcaption>画像ファイルのプレビュー</figcaption>
          <img src="" alt="" id="figureImage" style="max-width: 100%">
        </figure>
      </div>
    </form>
-----------------------------------------------------
input.addEventListener('change', (event) => { // <1>
    const [file] = event.target.files

    if (file) {
      figureImage.setAttribute('src', URL.createObjectURL(file))★setAttributeを使うのがポイント
      figure.style.display = 'block'★普段非表示で、画像選択されたときは表示する
    } else {
      figure.style.display = 'none'
    }
  })
★画像の位置調整は不明...



