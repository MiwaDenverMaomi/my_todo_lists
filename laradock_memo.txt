＜参考サイト＞
https://reffect.co.jp/laravel/laradock-laravel-macos#Laravel
https://qiita.com/mineaki27th/items/ad774a41b7a0a68761bd->こっちのほうがいいかも

１.localhostでLaravelのトップ画面が表示されず、権限に関するエラーが出た場合：
php-fpmフォルダ->Dockerfile->これに以下の文章を追記する。

【解決策】
RUN apt-get update && apt-get install -y libmcrypt-dev mysql-client && docker-php-ext-install mcrypt pdo_mysql
ADD . /var/www
RUN chown -R laradock:laradock /var/www　※laradock:laradockをwww-data:www-dataにしてもOKだった。よくわからん、、、。
＜参考＞
https://www.edureka.co/community/86899/stream-storage-laravel-opened-failed-stream-permission-denied
https://qiita.com/HiMinmeg/items/b1d0e6c717891e35674f

2.The stream or file "/var/www/storage/logs/laravel.log" could not be opened in append mode: failed to open stream: Permission denied The exception occurred while attempting to log: The stream or file "/var/www/storage/logs/laravel.log" could not be opened in append mode: failed to open stream: Permission denied The exception occurred while attempting to log: require(/var/www/routes/web.php): failed to open stream: No such file or directory Context: {"exception":{}} Context: {"exception":{}}
というエラーが出た。
【解決策】
docker内でchown $USER:laradock storage

＜参考＞
https://www.codegrepper.com/code-examples/shell/laravel.log%22+could+not+be+opened+in+append+mode%3A+failed+to+open+stream%3A+Permission+denied

3.tscコマンドが効かない
コンテナ内で./node_modules/.bin/tsc --initとするとOK

4.The mix-manifext not foundエラーが出る
C:\Users\Miwa\React\portfolio\laradock_2\bucket_list_materialui\app\Providers＞AppServiceProvider.php
で以下を記述
   public function boot()
    {
       $this->app->bind('path.public', function() {
       return base_path().'/public/';
    });
    }

5. npm run watchすると@material/uiが見つからないと言われる
->  "moduleResolution": "node"をts.configに追記。
※ts関連のエラーが続くようなので、最終形態のts.configを参照すべし。
->"include": [
  "src/**/*"
]を追記※場所に注意

6.material uiを使っている場合、@material/coreと@mui/materialは共存できないので注意。
7.@mui/stylesは使えない模様。->makeStylesが使えないので、const classes={}普通にオブジェクトで指定した。
8.コンパイルエラーがmixで出なくても、ブラウザコンソールでjsのエラーがあれば、正常にブラウザに表示されないので注意。コンソール上のエラーも解決すべし。

gitへのアップロード
1.laradockと同階層に.gitignoreを作成した。テンプレは以下を使用。これを使用してPUSHしたところ、プロジェクトのあるフォルダだけが
pushされた。
＜.gitignoreテンプレ＞ｄ
.idea
/logs
/data
.env
/.project
.docker-sync
/jenkins/jenkins_home

/logstash/pipeline/*.conf
/logstash/config/pipelines.yml

/nginx/ssl/*.crt
/nginx/ssl/*.key
/nginx/ssl/*.csr

/apache2/ssl/*.crt
/apache2/ssl/*.key
/apache2/ssl/*.csr
/apache2/ssl/*.org

/.devcontainer/*
!/.devcontainer/devcontainer.example.json
!/.devcontainer/docker-compose.extend-example.yml

docker-compose.custom.yml

.DS_Store

<Laravel>
・logが出ないときは、権限を変更。
chmod -R 777　なんちゃら

・画面作成以降のながれ
①画面作成（react,react-router）
②表示してみる
③MysqlでDB作成。mysql は、docker-compose exec mysql bash
④mysql -default -secretでmysqlに入る。※ユーザー、パスワードを変更しようと思ったが、ダメだった。
⑤DB名はデフォルトでdefaultとなっている。※変更のしかたは不明
⑥マイグレーション、フェイカーを使ってseeder。
⑦laravelでルーティング作成
⑧ルーティングに沿ってコントローラ作成
⑨テスト

・web.php　laravel 8ではこういう書き方をするらしい
Route::prefix('/bucket-lists')->group(function(){
    Route::get('/',[BucketListController::class,'index'])->name('bucket-lists.index');

・withでhasmanyやhasoneを取得したとき、必要なカラムのみ取得するにはどうしたらいいか

・$bucket_lists=User::with([
            'profile','bucket_list','likes'
            // 'profile:id,photo,question_1,question_2,question_3',
            // 'bucket_list:id,bucket_list_item,is_done,updated_at',
            // 'likes:id,from_user'
            ])->select('id','name','email')->get();
とりあえず、上のような書き方に落ち着いたが、必要なカラムのみ抽出できていない。

.更新のあった人のリストを最新に持っていきたい。
・入力ないpostrequestでのfrom_user,to_userなどのバリデーションは必要か
・laradock＋laravelでテスト用DBを作成する。
参考：https://qiita.com/yyy752/items/2252b26a2b1e03943ac2
①.envから.env.testingを作成。
APP_ENV=local
↓
APP_ENV=test

APP_KEY= //空にしておく

//接続したいテスト用DBの情報を記述
DB_CONNECTION=mysql
DB_HOST=db
DB_PORT=3306
DB_DATABASE=test_db
DB_USERNAME=root
DB_PASSWORD=?????

②php artisan config:cache
③mysql -u root //ログイン
create database test_db名;　//データベース作成※ここで権限のエラーが出たら、exit->mysql -u root -p ->rootでログインする


④phpunit.xmlの設定変更※この辺もっと良い設定方法があるけど分からなかった。https://www.youtube.com/watch?v=Un3MAWph64Mを参照。
（DB_DATABASEがなければdatabase.sqliteが読まれる設定？ちょっと分からない。）
次にphpunit.xmlを開き、APP_ENVの値をtestingに変更します。

phpunit.xml
<php>
    <env name="APP_ENV" value="testing" force="true"/>
    <env name="DB_CONNECTION" value="mysql"/>
    <env name="BCRYPT_ROUNDS" value="4"/>
    <env name="CACHE_DRIVER" value="array"/>
    <env name="MAIL_DRIVER" value="array"/>
    <env name="QUEUE_CONNECTION" value="sync"/>
    <env name="SESSION_DRIVER" value="array"/>
</php>

⑤アプリケーションキーの設定
最後にコマンドを実行して.env.testingに新規でアプリケーションキーを設定します。
※これをしないと.envのAPP_KEYを参照してしまい、本番用のDBのデータが全部消えるので注意してください！


php artisan key:generate --env=testing
⑤ここで、 GRANT USAGE ON *.* TO `default`@`localhost`                  |
| GRANT ALL PRIVILEGES ON `test_db`.* TO `defという権限エラーが出たので、

⑥mysql でrootでログインし、grant all on test_db.* to 'defaut';としたが、
ダメだった。仕方ないので、grant all on *.* on 'default'とし、全権限をdefaultに与えた。
->test_dbアクセスやdd()で変数を参照できるようになった。

⑦テスト用データベースはphp artisan db:seed --database=test_dbで作ってもよいが、これだと設定を変える必要がある。	
use RefreshDatabase;を使うと、すべてのDBのデータが消えるので注意。

⑦php artisan migrate --env=testingすると、テスト用ＤＢにテーブルが作成される。これでdb:seedもする。

⑧php artinsa refresh　データベース削除、再作成

⑨phpunit.xmlの <server name="DB_CONNECTION" value="sqlite"/>のコメントマークを外すとテスト用DBで RefreshDatabaseしても本番用のDBのデータは消えない。

☆laravel メール機能の実装

1)make:controller XXX（ContactController）でメールを飛ばすコントローラーを作る
・バリデーション、バリデーションOKならメールするsend()し、['message'=>'OK','error'=>[]]を返す。（NGなら
['message'=>'NG','error'=>['message was not sent']]など。）
ここで、2)で作成したmailクラスをnewし、sendで送る

Mail::to($request->input('email'))->send(new Inquiry());
        Mail::to($request->config('MAIL_FROM_ADDRESS'))->send(new Respond());
        return response()->json([
            'result'=>'Email was sent!',
            'errors'=>[]
        ]);

2)make:mail XXX(Inqury)　で何のメールテンプレートにviewし、どんなsubjectで,どんな変数をテンプレート送るかを
定める。
  public function build()
    {
        return $this->view('emails.inquiry')
        ->subject('Thank you for your inquiry.')
        ->with(['data'=>$this->data]);
    }

3)emails>inquiry.blade.phpを作成し、
メールのテンプレートを作る。

★ $user_data=User::with(['profile','likes'])->select('id','name','email')->find($user->id)->toArray();だと
１人分のデータが取れるが
 $user_data=User::with(['profile','likes'])->select('id','name','email')->get()->toArray();だと全員のデータが取れてしまう。

★setUp():void関数を使おう。ここに記述した処理は、
すべてのテストに適用される。
protected $user;
protected setUp():void{
parent::setUp();//必要
User::factory(1)->create();
$user=User::find(4);
}

★requestをnewしたとき
queryにキーと値を追加したい場合は、
merge(['key'=>'sss'])を使う。$request->user_id=3とかやってはダメ。何も入らない。

★テストはひとつひとつ実行しないとエラーになるのか？

★複数create
  $data=[  ['from_user'=>5,'to_user'=>4],  ['from_user'=>8,'to_user'=>4]];
        $result=Like::insert($data);

★複合キー制約（カラムの組み合わせを指定することで、重複データの作成を避ける。）を利用しよう。
★ Syntax error or access violation: 1061 Duplicate key name 'favorites_from_user_to_user_unique' (SQ
  L: alter table `favorites` add unique `favorites_from_user_to_user_unique`(`from_user`, `to_user`))
$table->unique(['from_user','to_user]);で複合ユニーク制約が追加されるはずだが、このエラーが出てしまった。
よくわからないので、いろいろ試した結果、成功したのは以下２つ。
１）favoritesテーブルを新規作成するファイルで$table->unique(['from_user','to_user]);と記述。
２）追加のマイグレーションファイルで制約を追加する場合は、$table->unique(['from_user','to_user],'favorites_from_user_to_user')
その後、以下のコマンドで確認する。（show columns文ではないので注意。）
MySQL [test_db]> show index from favorites;

★gmailからメールを送る設定：
gmailアカウント->security->sign up->パスワード必要あれば変更->app passwordsを作成
これを含めた情報を以下のように貼り付ける

MAIL_MAILER=smtp
MAIL_HOST=smtp.gmail.com//ここ必要
MAIL_PORT=1025
MAIL_USERNAME=hoge@example.com // メールアドレス
MAIL_PASSWORD=hogehogehoge     // アプリパスワード
MAIL_FROM_ADDRESS=hoge@example.com  // MAIL_USERNAMEと同じ
MAIL_FROM_NAME=Laravel便り // メール送信元名

★responseの中にはcontentというプロパティがあり、そこにエラーメッセージなどを入れることができる。
★mix watchが遅すぎるので、https://qiita.com/suzu6/items/8a8246015e5b45e210c4を参照にしてみた。
docker-compose.ymlに４行追記した。

・キャメロンに聞きたいこと
〇メールが届かない
〇全リストを作成の場合、
いきなり全データを取得するか？
〇Laravel側でデータを加工するか？それともreact側で加工？
〇mix run watchがとても遅い。

★エイリアス登録のしかた
1)app/Library/Func.phpを作成、そこにファンクション記述
namespace App\Library
class Func extends Facade
{

  public function convertEmptyValueToNull($val){
    $result=(strlen($value)>0)?$val:null;
    return $result;
  }

}
2)エイリアスに登録
config/app.php
'ailias'に
'Func'=> App\Library\Func::class,
※namespaceと実際のフォルダ構成が一致していないとエイリアスが動かないので注意。

★laravel の認証用トークンとcsrfトークンは別ものらしい。
認証用トークンは、ログイン時に使う。csrfトークンは、フォーム送信時に使う。
"POST"、"PUT"、"PATCH"、"DELETE" HTMLフォームを定義するときはいつでも、CSRF保護ミドルウェアがリクエストを検証できるように、フォームに非表示のCSRF_tokenフィールドを含める必要があります。

★サンクタムのしくみ
①API認証②SPA認証がある。
API認証の流れ：
データベースにトークン保存用の単一のテーブル（personal_access_tokens）を作成する（※マイグレーションファイルは前述のコマンド実行時に作成済み）
ユーザーがログインに成功した時にトークンを発行（トークンはランダムの40桁の文字列をsha256のハッシュアルゴリズムでハッシュ化したもの）
発行したトークンをpersonal_access_tokensテーブルに保存
発行したトークンをユーザーに知らせる
トークン認証が必要なルーティングには->middleware('auth:sanctum')を定義する
リクエストが来た時にミドルウェアでリクエスト中のAuthorizationヘッダーに設定されたトークンとデータベースのトークンの値を照合しユーザーを識別する（トークンがそもそもない場合、一致するトークンがない場合は401エラーを返す）
トークンの照合に成功したユーザーは->middleware('auth:sanctum')内のルーティング処理を続行する
->SPAではセキュリティ上使用すべきではない。（ローカルストレージから盗まれたら終わりだから）

SPA認証の流れ：
config/sanctum.phpにLaravelセッションクッキーを使用して「ステートフル」な認証を維持するドメインを定義する
apiミドルウェアグループにsactumミドルウェアを追加する。→SPAからのリクエストをLaravelのセッションクッキーを使って認証できるようにする＆サードパーティまたはモバイルアプリケーションからのリクエストをAPIトークンを使用して認証できるようにする。
SPAのログインページで初めに/sanctum/csrf-cookieにリクエストを送信して、アプリケーションのCSRF保護を初期化する。（この処理でLaravelは現在のCSRFトークンを含むXSRF-TOKENクッキーをセットする）
ログイン成功後、Laravelがクライアントにセッションクッキーを発行し、後続の処理はこのセッションクッキーを介して自動的に認証される。（ログイン、後続の処理でのリクエスト時にはCSRF保護の初期化に発行されたXSRF-TOKENクッキーの値をX-XSRF-TOKENヘッダで送信する限り、後続のリクエストは自動的にCSRF保護が行える）
セッションの期限切れになった状態で認証が必要なAPIエンドポイントにリクエストすると401 or 419エラーを返す。（SPAでログインページにリダイレクトさせる）
->クッキーを使っている。

注意：
★C:\Users\Miwa\React\portfolio\laradock_2\bucket_list_materialui\app\Http\Middleware\VerifyCSRFToken
後で、    protected $except = [
            '*',//delete later
    ];を削除する。今回はPOSTSMANテスト用のためここに追記した。

・リレーションでつなげる際の第三引数を省略しないこと。省略すると、自動的に該当モデルのid番号にリンクされてしまう。
  public function profile(){
        return $this->hasOne(Profile::class,'user_id','to_user');*この場合、'to_user'を記述しないと、profileモデルのid番号とリンクしてしまう。
    }
取得した結果のサンプルを参照～！
・リレーション先のリレーションを参照するときは、「.」でつなげる。例）
with('user.profile')->,,,